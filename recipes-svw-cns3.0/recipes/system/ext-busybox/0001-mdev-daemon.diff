diff -Nurp busybox-1.26.2/util-linux/mdev.c busybox-1.26.2.new/util-linux/mdev.c
--- busybox-1.26.2/util-linux/mdev.c	2016-09-27 18:53:50.000000000 +0200
+++ busybox-1.26.2.new/util-linux/mdev.c	2018-09-19 12:55:31.219641596 +0200
@@ -71,9 +71,11 @@
 //kbuild:lib-$(CONFIG_MDEV) += mdev.o
 
 //usage:#define mdev_trivial_usage
-//usage:       "[-s]"
+//usage:       "[-s] [-d [-f]]"
 //usage:#define mdev_full_usage "\n\n"
 //usage:       "mdev -s is to be run during boot to scan /sys and populate /dev.\n"
+//usage:       "mdev -d runs mdev as daemon like udev. With -f it will stay in\n"
+//usage:       "the foreground instead of forking.\n"
 //usage:       "\n"
 //usage:       "Bare mdev is a kernel hotplug helper. To activate it:\n"
 //usage:       "	echo /sbin/mdev >/proc/sys/kernel/hotplug\n"
@@ -99,6 +101,7 @@
 #include "libbb.h"
 #include "common_bufsiz.h"
 #include "xregex.h"
+#include <linux/netlink.h>
 
 /* "mdev -s" scans /sys/class/xxx, looking for directories which have dev
  * file (it is of the form "M:m\n"). Example: /sys/class/tty/tty0/dev
@@ -250,6 +253,14 @@
 #endif
 
 
+#define BUFFER_SIZE (2*1024)
+#define MAX_ENV 32
+
+#ifndef SO_RCVBUFFORCE
+#define SO_RCVBUFFORCE 33
+#endif
+enum { RCVBUF = 128 * BUFFER_SIZE };
+
 static const char keywords[] ALIGN1 = "add\0remove\0"; // "change\0"
 enum { OP_add, OP_remove };
 
@@ -285,6 +296,7 @@ struct globals {
 #endif
 	struct rule cur_rule;
 	char timestr[sizeof("HH:MM:SS.123456")];
+	char *env[MAX_ENV];
 } FIX_ALIASING;
 #define G (*(struct globals*)bb_common_bufsiz1)
 #define INIT_G() do { \
@@ -1038,110 +1050,193 @@ static void signal_mdevs(unsigned my_pid
 	}
 }
 
+static void process_action(char *temp, unsigned my_pid)
+{
+	char *fw;
+	char *seq;
+	char *action;
+	char *env_devname;
+	char *env_devpath;
+	unsigned seqnum = seqnum; /* for compiler */
+	int seq_fd;
+	smalluint op;
+
+	/* Hotplug:
+	 * env ACTION=... DEVPATH=... SUBSYSTEM=... [SEQNUM=...] mdev
+	 * ACTION can be "add", "remove", "change"
+	 * DEVPATH is like "/block/sda" or "/class/input/mice"
+	 */
+	env_devname = getenv("DEVNAME"); /* can be NULL */
+	G.subsystem = getenv("SUBSYSTEM");
+	action = getenv("ACTION");
+	env_devpath = getenv("DEVPATH");
+	if (!action || !env_devpath /*|| !G.subsystem*/)
+		bb_show_usage();
+	fw = getenv("FIRMWARE");
+	seq = getenv("SEQNUM");
+	op = index_in_strings(keywords, action);
+
+	seq_fd = -1;
+	if (my_pid && seq) {
+		seqnum = atoll(seq);
+		seq_fd = wait_for_seqfile(seqnum);
+	}
+
+	dbg1("%s "
+		"ACTION:%s SEQNUM:%s SUBSYSTEM:%s DEVNAME:%s DEVPATH:%s"
+		"%s%s",
+		curtime(),
+		action, seq, G.subsystem, env_devname, env_devpath,
+		fw ? " FW:" : "", fw ? fw : ""
+	);
+
+	snprintf(temp, PATH_MAX, "/sys%s", env_devpath);
+	if (op == OP_remove) {
+		/* Ignoring "remove firmware". It was reported
+		 * to happen and to cause erroneous deletion
+		 * of device nodes. */
+		if (!fw)
+			make_device(env_devname, temp, op);
+	}
+	else {
+		make_device(env_devname, temp, op);
+		if (ENABLE_FEATURE_MDEV_LOAD_FIRMWARE) {
+			if (op == OP_add && fw)
+				load_firmware(fw, temp);
+		}
+	}
+
+	if (seq_fd >= 0) {
+		xwrite_str(seq_fd, utoa(seqnum + 1));
+		signal_mdevs(my_pid);
+	}
+}
+
+static void initial_scan(char *temp)
+{
+	struct stat st;
+
+	xstat("/", &st);
+	G.root_major = major(st.st_dev);
+	G.root_minor = minor(st.st_dev);
+
+	putenv((char*)"ACTION=add");
+
+	/* Create all devices from /sys/dev hierarchy */
+	recursive_action("/sys/dev",
+			 ACTION_RECURSE | ACTION_FOLLOWLINKS,
+			 fileAction, dirAction, temp, 0);
+}
+
 int mdev_main(int argc, char **argv) MAIN_EXTERNALLY_VISIBLE;
 int mdev_main(int argc UNUSED_PARAM, char **argv)
 {
+	int opt;
 	RESERVE_CONFIG_BUFFER(temp, PATH_MAX + SCRATCH_SIZE);
 
 	INIT_G();
 
-#if ENABLE_FEATURE_MDEV_CONF
-	G.filename = "/etc/mdev.conf";
-#endif
-
-	/* We can be called as hotplug helper */
-	/* Kernel cannot provide suitable stdio fds for us, do it ourself */
-	bb_sanitize_stdio();
-
 	/* Force the configuration file settings exactly */
 	umask(0);
 
 	xchdir("/dev");
 
-	if (argv[1] && strcmp(argv[1], "-s") == 0) {
-		/*
-		 * Scan: mdev -s
-		 */
-		struct stat st;
+	opt = getopt32(argv, "dsf");
 
 #if ENABLE_FEATURE_MDEV_CONF
+	G.filename = "/etc/mdev.conf";
+	if (opt & 3) {
 		/* Same as xrealloc_vector(NULL, 4, 0): */
 		G.rule_vec = xzalloc((1 << 4) * sizeof(*G.rule_vec));
+	}
 #endif
-		xstat("/", &st);
-		G.root_major = major(st.st_dev);
-		G.root_minor = minor(st.st_dev);
-
-		putenv((char*)"ACTION=add");
-
-		/* Create all devices from /sys/dev hierarchy */
-		recursive_action("/sys/dev",
-				 ACTION_RECURSE | ACTION_FOLLOWLINKS,
-				 fileAction, dirAction, temp, 0);
-	} else {
-		char *fw;
-		char *seq;
-		char *action;
-		char *env_devname;
-		char *env_devpath;
-		unsigned my_pid;
-		unsigned seqnum = seqnum; /* for compiler */
-		int seq_fd;
-		smalluint op;
-
-		/* Hotplug:
-		 * env ACTION=... DEVPATH=... SUBSYSTEM=... [SEQNUM=...] mdev
-		 * ACTION can be "add", "remove", "change"
-		 * DEVPATH is like "/block/sda" or "/class/input/mice"
+
+	if (opt & 1) {
+		/*
+		 * Daemon mode listening on uevent netlink socket.
 		 */
-		env_devname = getenv("DEVNAME"); /* can be NULL */
-		G.subsystem = getenv("SUBSYSTEM");
-		action = getenv("ACTION");
-		env_devpath = getenv("DEVPATH");
-		if (!action || !env_devpath /*|| !G.subsystem*/)
-			bb_show_usage();
-		fw = getenv("FIRMWARE");
-		seq = getenv("SEQNUM");
-		op = index_in_strings(keywords, action);
-
-		my_pid = getpid();
-		open_mdev_log(seq, my_pid);
-
-		seq_fd = -1;
-		if (seq) {
-			seqnum = atoll(seq);
-			seq_fd = wait_for_seqfile(seqnum);
-		}
-
-		dbg1("%s "
-			"ACTION:%s SUBSYSTEM:%s DEVNAME:%s DEVPATH:%s"
-			"%s%s",
-			curtime(),
-			action, G.subsystem, env_devname, env_devpath,
-			fw ? " FW:" : "", fw ? fw : ""
-		);
-
-		snprintf(temp, PATH_MAX, "/sys%s", env_devpath);
-		if (op == OP_remove) {
-			/* Ignoring "remove firmware". It was reported
-			 * to happen and to cause erroneous deletion
-			 * of device nodes. */
-			if (!fw)
-				make_device(env_devname, temp, op);
-		}
-		else {
-			make_device(env_devname, temp, op);
-			if (ENABLE_FEATURE_MDEV_LOAD_FIRMWARE) {
-				if (op == OP_add && fw)
-					load_firmware(fw, temp);
+		struct sockaddr_nl sa;
+		int fd;
+
+		// Subscribe for UEVENT kernel messages
+		sa.nl_family = AF_NETLINK;
+		sa.nl_pad = 0;
+		sa.nl_pid = getpid();
+		sa.nl_groups = 1 << 0;
+		fd = xsocket(AF_NETLINK, SOCK_DGRAM, NETLINK_KOBJECT_UEVENT);
+		xbind(fd, (struct sockaddr *) &sa, sizeof(sa));
+		close_on_exec_on(fd);
+
+		// Without a sufficiently big RCVBUF, a ton of simultaneous events
+		// can trigger ENOBUFS on read, which is unrecoverable.
+		// Reproducer:
+		//	uevent mdev &
+		// 	find /sys -name uevent -exec sh -c 'echo add >"{}"' ';'
+		//
+		// SO_RCVBUFFORCE (root only) can go above net.core.rmem_max sysctl
+		setsockopt_SOL_SOCKET_int(fd, SO_RCVBUF,      RCVBUF);
+		setsockopt_SOL_SOCKET_int(fd, SO_RCVBUFFORCE, RCVBUF);
+
+		/*
+		 * Make inital scan after the uevent socket is alive and
+		 * _before_ we fork away.
+		 */
+		if (opt & 2)
+			initial_scan(temp);
+
+		if (opt & 4)
+			bb_sanitize_stdio();
+		else
+			bb_daemonize_or_rexec(0, argv);
+
+		open_mdev_log(NULL, getpid());
+
+		for (;;) {
+			char netbuf[BUFFER_SIZE];
+			char *s, *end;
+			ssize_t len;
+			int idx = 0;
+
+			len = recv(fd, netbuf, BUFFER_SIZE - 1, 0);
+			if (len < 0) {
+				if (errno == EINTR)
+					continue;
+				bb_perror_msg_and_die("recv");
 			}
+			end = netbuf + len;
+			*end = '\0';
+
+			for (s = netbuf; s < end; s = s+strlen(s)+1) {
+				if (strchr(s, '=') && idx < MAX_ENV-1) {
+					G.env[idx++] = s;
+					putenv(s);
+				}
+			}
+			G.env[idx] = NULL;
+
+			process_action(temp, 0);
+
+			idx = 0;
+			while (G.env[idx])
+				bb_unsetenv(G.env[idx++]);
 		}
+	} else if (opt & 2) {
+		/*
+		 * Scan: mdev -s
+		 */
+		initial_scan(temp);
+	} else {
+		unsigned my_pid = getpid();
+
+		/* We can be called as hotplug helper */
+		/* Kernel cannot provide suitable stdio fds for us, do it ourself */
+		bb_sanitize_stdio();
+
+		open_mdev_log(NULL, my_pid);
+
+		process_action(temp, my_pid);
 
 		dbg1("%s exiting", curtime());
-		if (seq_fd >= 0) {
-			xwrite_str(seq_fd, utoa(seqnum + 1));
-			signal_mdevs(my_pid);
-		}
 	}
 
 	if (ENABLE_FEATURE_CLEAN_UP)
